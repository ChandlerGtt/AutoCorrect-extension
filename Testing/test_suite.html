<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AutoCorrect Test Suite</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      overflow: hidden;
    }
    
    header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      text-align: center;
    }
    
    header h1 {
      font-size: 32px;
      margin-bottom: 10px;
    }
    
    header p {
      opacity: 0.9;
      font-size: 16px;
    }
    
    .controls {
      padding: 30px;
      background: #f8f9fa;
      border-bottom: 2px solid #e9ecef;
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    button {
      background: #667eea;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    button:hover {
      background: #5568d3;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }
    
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    
    .test-input {
      flex: 1;
      min-width: 300px;
      padding: 12px;
      border: 2px solid #dee2e6;
      border-radius: 6px;
      font-size: 16px;
      font-family: 'Courier New', monospace;
    }
    
    .stats {
      padding: 30px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
    }
    
    .stat-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
    }
    
    .stat-card .value {
      font-size: 36px;
      font-weight: bold;
      margin: 10px 0;
    }
    
    .stat-card .label {
      font-size: 14px;
      opacity: 0.9;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .results {
      padding: 30px;
    }
    
    .result-item {
      display: grid;
      grid-template-columns: 200px 200px 200px 1fr auto;
      gap: 15px;
      padding: 15px;
      border-bottom: 1px solid #e9ecef;
      align-items: center;
      font-family: 'Courier New', monospace;
    }
    
    .result-item:nth-child(even) {
      background: #f8f9fa;
    }
    
    .result-header {
      font-weight: bold;
      background: #667eea !important;
      color: white;
      font-family: 'Segoe UI', sans-serif;
      border-radius: 6px;
      margin-bottom: 10px;
    }
    
    .misspelled {
      color: #dc3545;
      font-weight: bold;
    }
    
    .corrected {
      color: #28a745;
      font-weight: bold;
    }
    
    .expected {
      color: #007bff;
    }
    
    .badge {
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: bold;
      text-transform: uppercase;
    }
    
    .badge.success {
      background: #d4edda;
      color: #155724;
    }
    
    .badge.failure {
      background: #f8d7da;
      color: #721c24;
    }
    
    .progress-bar {
      width: 100%;
      height: 6px;
      background: #e9ecef;
      border-radius: 3px;
      overflow: hidden;
      margin: 20px 0;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      transition: width 0.3s;
      width: 0%;
    }
    
    .test-status {
      text-align: center;
      padding: 20px;
      font-size: 18px;
      color: #495057;
    }
    
    #exportBtn {
      background: #28a745;
    }
    
    #exportBtn:hover {
      background: #218838;
    }
    
    /* Hidden test input for extension to interact with */
    #hiddenTestInput {
      position: absolute;
      left: -9999px;
      width: 1px;
      height: 1px;
    }
  </style>
</head>
<body>
  <!-- Hidden input field that the extension content script will interact with -->
  <textarea id="hiddenTestInput"></textarea>

  <div class="container">
    <header>
      <h1>üîç AutoCorrect Test Suite</h1>
      <p>Automated accuracy testing with 47 misspelling examples</p>
    </header>
    
    <div class="controls">
      <button id="runTestBtn">‚ñ∂Ô∏è Run All Tests</button>
      <button id="exportBtn">üì• Export Results (CSV)</button>
      <input type="text" class="test-input" id="customTest" placeholder="Type to test individual words...">
    </div>
    
    <div class="progress-bar">
      <div class="progress-fill" id="progressBar"></div>
    </div>
    
    <div class="test-status" id="status">Click "Run All Tests" to begin...</div>
    
    <div class="stats">
      <div class="stat-card">
        <div class="label">Total Tests</div>
        <div class="value" id="totalTests">0</div>
      </div>
      <div class="stat-card">
        <div class="label">Passed</div>
        <div class="value" id="passedTests">0</div>
      </div>
      <div class="stat-card">
        <div class="label">Failed</div>
        <div class="value" id="failedTests">0</div>
      </div>
      <div class="stat-card">
        <div class="label">Accuracy</div>
        <div class="value" id="accuracy">0%</div>
      </div>
    </div>
    
    <div class="results">
      <div class="result-item result-header">
        <div>Misspelled</div>
        <div>Corrected To</div>
        <div>Expected</div>
        <div>Context</div>
        <div>Result</div>
      </div>
      <div id="resultsList"></div>
    </div>
  </div>

  <script>
    // Comprehensive test dataset with common misspellings
    const testData = [
      // Common typos
      { word: 'teh', expected: 'the', context: 'teh quick brown' },
      { word: 'recieve', expected: 'receive', context: 'I will recieve it' },
      { word: 'seperate', expected: 'separate', context: 'seperate the items' },
      { word: 'definately', expected: 'definitely', context: 'definately going there' },
      { word: 'occured', expected: 'occurred', context: 'it occured yesterday' },
      { word: 'thier', expected: 'their', context: 'thier house is' },
      { word: 'freind', expected: 'friend', context: 'my best freind' },
      { word: 'wierd', expected: 'weird', context: 'that is wierd' },
      { word: 'beleive', expected: 'believe', context: 'I beleive you' },
      { word: 'untill', expected: 'until', context: 'wait untill tomorrow' },
      
      // Double letter errors
      { word: 'begining', expected: 'beginning', context: 'the begining of' },
      { word: 'occassion', expected: 'occasion', context: 'special occassion today' },
      { word: 'accomodate', expected: 'accommodate', context: 'can accomodate guests' },
      { word: 'tommorrow', expected: 'tomorrow', context: 'see you tommorrow' },
      { word: 'succesful', expected: 'successful', context: 'very succesful project' },
      
      // Transposition errors
      { word: 'thsi', expected: 'this', context: 'thsi is important' },
      { word: 'taht', expected: 'that', context: 'taht was great' },
      { word: 'waht', expected: 'what', context: 'waht is it' },
      { word: 'wiht', expected: 'with', context: 'come wiht me' },
      { word: 'hte', expected: 'the', context: 'hte best one' },
      
      // Phonetic errors
      { word: 'nite', expected: 'night', context: 'good nite everyone' },
      { word: 'lite', expected: 'light', context: 'lite the candle' },
      { word: 'rite', expected: 'right', context: 'you are rite' },
      { word: 'thru', expected: 'through', context: 'go thru the door' },
      
      // Missing letters
      { word: 'becase', expected: 'because', context: 'becase I said so' },
      { word: 'enviroment', expected: 'environment', context: 'clean enviroment matters' },
      { word: 'goverment', expected: 'government', context: 'the goverment decided' },
      { word: 'realy', expected: 'really', context: 'realy good food' },
      { word: 'basicly', expected: 'basically', context: 'basicly it works' },
      
      // Extra letters
      { word: 'arguement', expected: 'argument', context: 'had an arguement' },
      
      // More common mistakes
      { word: 'writting', expected: 'writing', context: 'writting a letter' },
      { word: 'knowlege', expected: 'knowledge', context: 'common knowlege is' },
      { word: 'calender', expected: 'calendar', context: 'check the calender' },
      { word: 'maintainance', expected: 'maintenance', context: 'routine maintainance required' },
      { word: 'noticable', expected: 'noticeable', context: 'very noticable difference' },
      { word: 'paralell', expected: 'parallel', context: 'paralell lines never' },
      { word: 'reccommend', expected: 'recommend', context: 'I reccommend this' },
      { word: 'surprize', expected: 'surprise', context: 'a big surprize' },
      { word: 'truely', expected: 'truly', context: 'truely amazing work' },
      { word: 'unfortunatly', expected: 'unfortunately', context: 'unfortunatly we cannot' },
      { word: 'vaccuum', expected: 'vacuum', context: 'use the vaccuum' },
      { word: 'wheather', expected: 'whether', context: 'wheather or not' },
      { word: 'mispell', expected: 'misspell', context: 'do not mispell' },
      { word: 'neccessary', expected: 'necessary', context: 'it is neccessary' },
      { word: 'publically', expected: 'publicly', context: 'publically announced yesterday' },
      { word: 'concious', expected: 'conscious', context: 'fully concious now' },
      { word: 'existance', expected: 'existence', context: 'proof of existance' },
      { word: 'guage', expected: 'gauge', context: 'check the guage' },
    ];

    let results = [];
    let testRunning = false;

    // DOM elements
    const hiddenInput = document.getElementById('hiddenTestInput');
    const runTestBtn = document.getElementById('runTestBtn');
    const exportBtn = document.getElementById('exportBtn');
    const customTestInput = document.getElementById('customTest');
    const progressBar = document.getElementById('progressBar');
    const statusDiv = document.getElementById('status');
    const resultsList = document.getElementById('resultsList');
    const totalTestsEl = document.getElementById('totalTests');
    const passedTestsEl = document.getElementById('passedTests');
    const failedTestsEl = document.getElementById('failedTests');
    const accuracyEl = document.getElementById('accuracy');

    // Simulate autocorrect by typing into hidden input and observing correction
    async function testAutocorrect(word, context) {
      return new Promise((resolve) => {
        // Clear the input
        hiddenInput.value = '';
        hiddenInput.focus();
        
        // Type the word
        hiddenInput.value = word;
        
        console.log(`[TEST] Testing word: "${word}"`);
        
        // Observe value changes using MutationObserver
        let finalCorrectedValue = word;
        let changeDetected = false;
        
        const observer = new MutationObserver((mutations) => {
          const currentValue = hiddenInput.value.trim();
          if (currentValue && currentValue !== word) {
            finalCorrectedValue = currentValue;
            changeDetected = true;
            console.log(`[TEST] Observer detected change to: "${finalCorrectedValue}"`);
          }
        });
        
        // Observe the input element for any changes
        observer.observe(hiddenInput, { 
          attributes: true, 
          attributeFilter: ['value'],
          characterData: true,
          subtree: true
        });
        
        // Also listen to input events as backup
        const inputListener = () => {
          const currentValue = hiddenInput.value.trim();
          if (currentValue && currentValue !== word) {
            finalCorrectedValue = currentValue;
            changeDetected = true;
            console.log(`[TEST] Input event detected change to: "${finalCorrectedValue}"`);
          }
        };
        
        hiddenInput.addEventListener('input', inputListener);
        
        // Trigger input event
        hiddenInput.dispatchEvent(new Event('input', { bubbles: true }));
        
        // Move cursor to end
        hiddenInput.selectionStart = word.length;
        hiddenInput.selectionEnd = word.length;
        
        const beforeSpace = hiddenInput.value;
        console.log(`[TEST] Value before space: "${beforeSpace}"`);
        
        // Simulate space keydown (triggers autocorrect)
        const keydownEvent = new KeyboardEvent('keydown', {
          key: ' ',
          code: 'Space',
          bubbles: true,
          cancelable: true
        });
        hiddenInput.dispatchEvent(keydownEvent);
        
        // Wait for correction to complete
        setTimeout(() => {
          // Clean up
          observer.disconnect();
          hiddenInput.removeEventListener('input', inputListener);
          
          // Get final value - prefer the observed change if detected
          const directValue = hiddenInput.value.trim();
          const result = changeDetected ? finalCorrectedValue : directValue;
          
          console.log(`[TEST] Final raw value: "${hiddenInput.value}"`);
          console.log(`[TEST] Direct trimmed: "${directValue}"`);
          console.log(`[TEST] Observed value: "${finalCorrectedValue}"`);
          console.log(`[TEST] Returning: "${result}"`);
          console.log(`[TEST] Changed: ${word !== result ? 'YES ‚úì' : 'NO ‚úó'}`);
          
          resolve(result || word);
        }, 1200); // Even longer wait - 1.2 seconds
      });
    }

    // Run all tests
    async function runAllTests() {
      if (testRunning) return;
      
      testRunning = true;
      runTestBtn.disabled = true;
      results = [];
      resultsList.innerHTML = '';
      
      totalTestsEl.textContent = testData.length;
      passedTestsEl.textContent = '0';
      failedTestsEl.textContent = '0';
      accuracyEl.textContent = '0%';
      
      let passed = 0;
      let failed = 0;
      
      for (let i = 0; i < testData.length; i++) {
        const test = testData[i];
        
        statusDiv.textContent = `Testing ${i + 1}/${testData.length}: "${test.word}"...`;
        progressBar.style.width = ((i / testData.length) * 100) + '%';
        
        // Test the word
        const corrected = await testAutocorrect(test.word, test.context);
        const success = corrected.toLowerCase() === test.expected.toLowerCase();
        
        if (success) {
          passed++;
        } else {
          failed++;
        }
        
        // Store result
        const result = {
          word: test.word,
          corrected: corrected,
          expected: test.expected,
          context: test.context,
          success: success
        };
        results.push(result);
        
        // Update UI
        addResultRow(result);
        passedTestsEl.textContent = passed;
        failedTestsEl.textContent = failed;
        
        const accuracy = ((passed / (passed + failed)) * 100).toFixed(1);
        accuracyEl.textContent = accuracy + '%';
        
        // Delay between tests
        await new Promise(resolve => setTimeout(resolve, 200));
      }
      
      progressBar.style.width = '100%';
      statusDiv.textContent = `‚úÖ Testing complete! Accuracy: ${((passed / testData.length) * 100).toFixed(1)}%`;
      
      testRunning = false;
      runTestBtn.disabled = false;
    }

    // Add result row to UI
    function addResultRow(result) {
      const row = document.createElement('div');
      row.className = 'result-item';
      
      row.innerHTML = `
        <div class="misspelled">${result.word}</div>
        <div class="corrected">${result.corrected}</div>
        <div class="expected">${result.expected}</div>
        <div>${result.context}</div>
        <div>
          <span class="badge ${result.success ? 'success' : 'failure'}">
            ${result.success ? '‚úì Pass' : '‚úó Fail'}
          </span>
        </div>
      `;
      
      resultsList.appendChild(row);
      
      // Auto-scroll to latest result
      row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }

    // Export results to CSV
    function exportResults() {
      if (results.length === 0) {
        alert('Run tests first!');
        return;
      }
      
      let csv = 'Misspelled,Corrected,Expected,Context,Result\n';
      
      results.forEach(result => {
        csv += `"${result.word}","${result.corrected}","${result.expected}","${result.context}","${result.success ? 'PASS' : 'FAIL'}"\n`;
      });
      
      // Add summary stats
      const passed = results.filter(r => r.success).length;
      const failed = results.filter(r => !r.success).length;
      const accuracy = ((passed / results.length) * 100).toFixed(1);
      
      csv += '\n';
      csv += `Total Tests,${results.length}\n`;
      csv += `Passed,${passed}\n`;
      csv += `Failed,${failed}\n`;
      csv += `Accuracy,${accuracy}%\n`;
      
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `autocorrect-test-results-${Date.now()}.csv`;
      a.click();
    }

    // Event listeners
    runTestBtn.addEventListener('click', runAllTests);
    exportBtn.addEventListener('click', exportResults);
    
    console.log('üß™ AutoCorrect Test Suite Ready!');
    console.log('üìä Test dataset contains', testData.length, 'examples');
    console.log('üí° Make sure your AutoCorrect extension is enabled!');
  </script>
</body>
</html>